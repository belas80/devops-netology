# 6.6. Troubleshooting  

## Задача 1  

   Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и
   её нужно прервать.  
   
   Остановка запроса пользователя:  
   * Вычислим проблемный запрос, в `mongosh` выполним `db.currentOp({"secs_running":{$gte: 3}})`, вернется документ,
     содержащий информацию о выполняемых 3 и более минут операциях.
   * С помощью `db.killOp(opid)`, используя информацию из предыдущего запроса, остановим запрос.  
   
   Для решения проблемы с долгими (зависающими) запросами в MongoDB, можно воспользоваться методом 
   [`.explain("executionStats")`](https://docs.mongodb.com/manual/tutorial/analyze-query-plan/) для конкретного запроса,
   который покажет информацию о его выполнении и уже на основании этого смотреть что же с ним не так.  
   
## Задача 2  

   Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение
   количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается 
   пропорционально количеству реплик сервиса.

   При масштабировании сервиса до N реплик вы увидели, что:

   * сначала рост отношения записанных значений к истекшим
   * Redis блокирует операции записи  

   Проблема может быть в том, что в БД более 25% значений, срок действия которых уже истек, и Redis вытесняет их 
   блокируя операции, чтобы снизить их количество ниже 25%.  
   
## Задача 3  

   При росте количества записей, в таблицах базы данных MySQL, пользователи начали жаловаться на ошибки вида:  
   ```bash
   InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
   ```
   Возможно это стало происходить при росте количества записей, когда миллионы строк отправляются как часть одного или 
   нескольких запросов. Можно попробовать увеличить `net_read_timeout` значение по умолчанию, равное 30 секундам, до 60 
   секунд или больше. И как вариант использовать шардирование таблиц.  
   
## Задача 4  

   После запуска PostgreSQL пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg 
   вы видите, что:  
   ```bash
   postmaster invoked oom-killer
   ```
   Нехватка ресурсов. Когда системе не хватает памяти, `OMM killer` вызывает и убивает процесс `postgesql`.  
   Необходимо проверить настройки памяти в соответствии с оборудованием, а так же, по возможности, добавить оперативной 
   памяти.  
   
   **Добавлено:** что будем крутить  
   
   Для начала можно посмотреть на `swap`, возможно он вообще отключен, т.е. в `/proc/sys/vm/swappiness` стоит 0. И если
   БД полностью помещается в память, то рекомендуется установить это значение в 1.  
   ```bash
   vagrant@vagrant:~$ sudo sysctl -w vm.swappiness=1
   ```
   Либо, если хотим сохранить значение после перезагрузки  
   ```bash
   root@vagrant:~# echo "vm.swappiness=1" >> /etc/sysctl.conf
   ```
   В общем чем больше значение `swappiness`, тем меньше шансов, что OOM Killer завершить процесс. Но, так как при этом
   будет интенсивнее использоваться подкачка, это негативно скажется на производительности.  
   
   Так же можно поуправлять поведением OOM Killer для конкретного процесса, с помощью параметра `oom_score_adj`.
   Добавив большое отрицательное значение, снизятся шансы на завершение дорогого нам процесса.  
   ```bash
   root@vagrant:~# echo -1000 > /proc/PID/oom_score_adj
   ```
   Можно задать его в блоке `Service` юнита  
   ```bash
   [Service]
   OOMScoreAdjust=-1000
   ```
   Еще можно установить `vm.overcommit_memory` в 2 (по умолчению 0). Тогда ядро не будет резервировать больше памяти, 
   чем указано в параметре `vm.overcommit_ratio`. Это самый безопасный вариант, рекомендуемый для PosgreSQL. Настраивается 
   с помощью `sysctl` либо в `/etc/sysctl.conf`.  