# 4.1. Командная оболочка Bash: Практические навыки  
1. Скрипт
    ```bash
    a=1
    b=2
    c=a+b
    d=$a+$b
    e=$(($a+$b))
    echo c=$c; echo d=$d; echo e=$e
    c=a+b
    d=1+2
    e=3
    ```
   `c=a+b` - мы не указали что `a` и `b` переменные с помощью символа `$`, поэтому получилась просто строка `a+b`, никак не связанная с объявленными выше `a=1 b=2`  
   `d=1+2` - переменные `a` и `b` мы указали в неявном виде, поэтому здесь получили так же строку, но с подстановкой значений объявленных переменных `1+2`  
   `e=3` - заключив выражение в двойные скобки и дополнив знаком `$`, получили операцию сложения `1+2=3`  
2. В скрипте не хватает закрывающей скобки в команде `while`. Чтобы место на жестком диске не заканчивалось, можно оставить один `>` в команде `date`, тогда файл `curl.log` все время будет перезаписываться последней датой неучачной проверки. А чтобы прервать скрипт, как только хост станет доступным, нужно добавить в конструкцию `if` выход `break`. Т.е. правильно скрипт будет выглядеть так  
   ```bash
   while ((1==1))
   do
     curl https://localhost:4757
     if (($? != 0))
     then
       date > curl.log
     else
       break
     fi
   done
   ```
3. Скрипт, который проверяет доступность трёх IP: 192.168.0.1, 173.194.222.113, 87.250.250.242 по 80 порту, пять раз для каждого узла и записывает результат в файл log.  
   ```bash
   #!/usr/bin/env bash
   
   addr_chk=(192.168.1.28 173.194.222.113 87.250.250.242)
   rm myscript.log
   
   while ((1==1))
   do
     for i in ${addr_chk[@]}
     do
       n=5
       while (($n>0))
         do
           curl http://$i
           echo "Exit code for "$i " - " $? >> myscript.log
           let n-=1
         done
       done
   done
   ```
4. Допишем скрипт из предыдущего задания так, чтобы он выполнялся до тех пор, пока один из узлов не окажется недоступным, добавив проверку кода возврата команды `curl` через `if`.  
   ```bash
   #!/usr/bin/env bash
   
   addr_chk=(192.168.1.28 173.194.222.113 87.250.250.242)
   rm mysсript.log
   
   while ((1==1))
   do
     for i in ${addr_chk[@]}
     do
       n=5
       while (($n>0))
       do
           curl http://$i
           if (($? != 0))
           then
               echo "Exit code for "$i " - "$? >> error.log
               break 4
           fi
           echo "Exit code for "$i " - " $? >> mysсript.log
           let n-=1
       done
     done
   done
   ```
* Локальный хук сообщения коммита с органичением в 30 символов по примеру: [04-script-01-bash] сломал хук.  
   Будем использовать регулярные выражения, чтобы проверить сообщение на соответствие примеру. Код задания должен быть в квадратных скобках и в начале строки, для этого сделаем следующий шаблон `^(\[[0-9]{2}-[a-z]+-[0-9]{2}-[a-z]+\])`, а сообщение, что идет после этого кода, ограничим 30-ю любыми символами `(.{3,30})$`. Далее, если не сгрепаем по регулярному выражению сообщение коммита, то выйдем со статусом 1 и коммит не применится.  
   Создадим файл `.git/hooks/commit-msg` следующего содержания  
   ```bash
   #!/usr/bin/env bash  
   commitRegex='^(\[[0-9]{2}-[a-z]+-[0-9]{2}-[a-z]+\]) (.{3,30})$'
   if ! grep -E "$commitRegex" "$1"
   then
     echo "The commit message does not match format"
     exit 1
   fi
   ```
   Сделаем его исполняемым `chmod +x .git/hooks/commit-msg` и проверим  
   ```bash
   
   ```